//=============================================================================
//
//  API for Myki Business Rules package
//
//  This is the primary header file for this package. It includes all necessary
//  secondary header files.
//
//=============================================================================

#ifndef BR_MYKI_H
#define BR_MYKI_H

#ifdef __cplusplus
extern "C" {
#endif

#include <myki_br_context_data.h>
#include <myki_br_rules.h>

//
//  Value returned from MYKI_BR_Execute(), remapped from SEQ_RESULT_xxx by MYKI_BR_Execute().
//

typedef enum
{
    MYKI_BR_RESULT_ERROR,
    MYKI_BR_RESULT_SUCCESS,
    MYKI_BR_RESULT_OPEN_GATE = MYKI_BR_RESULT_SUCCESS,  // legacy (replace everywhere with MYKI_BR_RESULT_SUCCESS) - KWS, actually this should be left as it was, to match the BR document. Change back when calling code is changed.
    MYKI_BR_RESULT_REJECT,

} BusinessRulesResult_e;

//
//  Sequence Results (these and the MYKI_BR_ContextData_t structure are the only remaining issue that prevents the business rules engine
//  from being totally independent of the Myki specific business rules).
//

typedef enum
{
    //  Marker indicating end of action list plus default action if no match is found. Only used in sequence definitions, never explicitly
    //  returned, although it is returned by a "default" action caused by an implicit end-of-action list as described below.
    //  Must be first in this list to give it a value of 0, as this removes the need to explicitly include it in the static sequence
    //  definitions (as all not-explicitly-set elements are set to 0 by the compiler/runtime).

    SEQ_RESULT_DEFAULT = 0,             // Explicitly ensure it's zero (see above)

    //  Results generated by business rules engine itself.

    SEQ_RESULT_INTERNAL_ERROR,          // Internal coding error

    //  Results returned from execution of business rules (re-mapped from the BR_RESULT_xxx value)

    SEQ_RESULT_EXECUTED,                // Remapped from BR_RESULT_EXECUTED
    SEQ_RESULT_BYPASSED,                // Remapped from BR_RESULT_BYPASSED
    SEQ_RESULT_ERROR,                   // Remapped from BR_RESULT_ERROR

    //  Results returned from execution of sequences.

    SEQ_RESULT_CONTINUE,                // For SEQ_ID_LLSC_0A
    SEQ_RESULT_REJECT,                  // For SEQ_ID_LLSC_0A
    SEQ_RESULT_SCAN_ON,                 // Formerly SEQ_RESULT_OPEN_GATE - Updated to reflect the needs of devices other than gates
    SEQ_RESULT_SCAN_OFF,                // -  and to provide granularity back to the readerapp so it can display the correct 
    SEQ_RESULT_OPERATOR,                // -  HMI message when in onboard or static modes (entry/exit sequence)
    SEQ_RESULT_CARD_INITIALISED,
    SEQ_RESULT_MULTIPLE_CARDS,
    SEQ_RESULT_ACTIONLISTS_PROCESSED,
    SEQ_RESULT_INVALID_TRANSIT_APPLICATION_STATUS,
    SEQ_RESULT_AUTOLOAD_PROCESSED,      // aka "Products Managed"
    SEQ_RESULT_CHANGE_OF_MIND,
    SEQ_RESULT_SCAN_OFF_REQUIRED,
    SEQ_RESULT_FORCED_SCAN_OFF,
    SEQ_RESULT_NO_CHANGE_OF_MIND,
    SEQ_RESULT_NO_MISSING_SCAN_OFF,
    SEQ_RESULT_UNABLE_TO_SCAN_OFF,
    SEQ_RESULT_TPURSE_BALANCE_BELOW_MINIMUM,
    SEQ_RESULT_STATION_EXIT_FEE_CHARGED,
    SEQ_RESULT_MISSING_SCAN_ON,
    SEQ_RESULT_SCAN_ON_PRESENT,
    SEQ_RESULT_PRODUCT_SCANNED_ON,
    SEQ_RESULT_RESCAN_ON_COMPLETE,
    SEQ_RESULT_NO_SCANNED_ON_PRODUCT,
    SEQ_RESULT_SCAN_OFF_PERFORMED,
    SEQ_RESULT_SCAN_OFF_WITH_PARTIAL_COVERAGE,
    SEQ_RESULT_FORCED_SCAN_OFF_PENALTY,
    SEQ_RESULT_CAPPING_PROCESSED,
    SEQ_RESULT_MERGE_PRODUCTS,
    SEQ_RESULT_SCAN_OFF_FINALIZED,
    SEQ_RESULT_DUPLICATE_SCAN_ON,
    SEQ_RESULT_NO_DUPLICATE_SCAN_ON,
    SEQ_RESULT_BLOCKING_PERIOD_APPLIES,
    SEQ_RESULT_BLOCKING_PERIOD_EXPIRED,
    SEQ_RESULT_TRAVEL_ACCESS_PASS_IN_USE,
    SEQ_RESULT_ZONE_RANGE_DETERMINED,
    SEQ_RESULT_NO_SCANNED_ON_PRODUCTS,
    SEQ_RESULT_SCAN_ON_TRAVEL_ACCESS_PASS,
    SEQ_RESULT_SCAN_OFF_TRAVEL_ACCESS_PASS,

    SEQ_RESULT_PASSTHROUGH,     // Special result used only in sequence definitions, means pass through result from subsequence unchanged

    SEQ_RESULT_PRECOMMIT_CHECK_FAILED,

    SEQ_RESULT_MAX

}   SequenceResult_e;

#define MAX_STEPS_PER_SEQUENCE          50
#define MAX_RESULT_ACTIONS_PER_STEP     10

typedef enum
{
    ACTION_TYPE_RETURN,                 // Must be first in this list to make it the default action
    ACTION_TYPE_GOTO_SEQ,
    ACTION_TYPE_GOTO_RULE

}   ActionType_e;

typedef enum
{
    STEP_TYPE_SEQ,
    STEP_TYPE_RULE,
    STEP_TYPE_DONE

}   StepType_e;

    /** Sequence function to be executed */
typedef enum
{
    SEQ_FUNCTION_DEFAULT = (0),

    /*  Operator sequence functions */
    SEQ_FUNCTION_VALIDATE_PIN,          // Validate operator PIN
    SEQ_FUNCTION_UPDATE_PIN,            // Update operator PIN
    SEQ_FUNCTION_UPDATE_SHIFT_DATA,     // Update operator PIN

    /*  Transit sequence functions */
    SEQ_FUNCTION_ADD_VALUE = (25),      // TPurse top-up
    SEQ_FUNCTION_ADD_VALUE_REVERSAL,    // TPurse top-up reversal
    SEQ_FUNCTION_DEBIT_TPURSE_VALUE,
    SEQ_FUNCTION_DEBIT_TPURSE_VALUE_REVERSAL,

}   SequenceFunction_e;

typedef struct Sequence_t   Sequence_t; // Forward declaration because Sequence_t contains Step_t contains ResultAction_t contains Sequence_t

typedef RuleResult_e (MYKI_BR_RuleFunc_t)( MYKI_BR_ContextData_t *pData );     // Typedef'd prototype for business rule function, so it can be used in structures below

typedef struct
{
    SequenceResult_e    ResultValue;    // The result value from this step that triggers this action
    ActionType_e        ActionType;     // The type of action to execute if the step returned the above result value
    Sequence_t          *pSequence;     // Pointer to sequence to go to (only valid for ACTION_TYPE_GOTO_SEQ)
    MYKI_BR_RuleFunc_t  *pRuleFunc;     // Pointer to rule function to call (only valid for ACTION_TYPE_GOTO_RULE)
    SequenceResult_e    ReturnResult;   // Value to return from this step (only valid for ACTION_TYPE_RETURN)
    char                *Desc;          // Text description of target - Sequence, Rule or Result

}   ResultAction_t;

typedef struct
{
    int                 Type;           // STEP_TYPE_SEQ or STEP_TYPE_RULE
    Sequence_t          *pSequence;     // Pointer to sequence to go to (only valid for STEP_TYPE_SEQ)
    MYKI_BR_RuleFunc_t  *pRuleFunc;     // Pointer to rule function to call (only valid for STEP_TYPE_RULE)
    char                *IdDesc;        // Text description of sequence or rule

    ResultAction_t  ResultAction[ MAX_RESULT_ACTIONS_PER_STEP ];

}   Step_t;

struct Sequence_t                       // Done this way because of forward declaration above
{
    char        *IdDesc;                // Text description of sequence

    Step_t      StepList[ MAX_STEPS_PER_SEQUENCE ];
};

//
//  Export sequences so they can be analysed by the test module
//

extern  Sequence_t  SEQ_ProcessCard;    // Will probably only need this one

//
//  Function Prototypes
//

int                 MYKI_BR_Initialise( int initialStationEntryPointId );
int                 MYKI_BR_Finalise();
int                 MYKI_BR_Execute( MYKI_BR_ContextData_t *pData );
int                 MYKI_BR_ExecuteSequence( MYKI_BR_ContextData_t *pData, SequenceFunction_e sequenceFunction );
int                 MYKI_BR_InitialiseContext( MYKI_BR_ContextData_t *pData );
void                MYKI_BR_InitialiseLdtContext( MYKI_BR_ContextData_t *pData );

SequenceResult_e    MYKI_BR_RunSequence( Sequence_t *pSequence, MYKI_BR_ContextData_t *pSequenceData );
int                 MYKI_BR_PrintSequence( Sequence_t *pSequence, int level );
int                 MYKI_BR_PrintSequenceRules( Sequence_t *pSequence );
char                *MYKI_BR_SequenceResultDesc( SequenceResult_e result );
int                 MYKI_BR_PrintSequencePaths( Sequence_t *pSequence, int level );
int                 MYKI_BR_PrintSequencePathsTest();

#ifdef __cplusplus
}
#endif

#endif  // BR_MYKI_H
